#include <metal_stdlib>
#include <metal_compute>
using namespace metal;

#define TILE_SIZE 1

// K_ptr: Metal kernel function parameters must be pointers to buffers or scalar values stored in buffers.
// Metal does not support passing integers directly as kernel parameters—you need to pass them via a buffer.
// `thread_position_in_grid` is a built-in Metal attribute, which means:
// - It is automatically provided by Metal when the kernel function is executed.
// - It does not come from the CPU like other kernel parameters.
// - It is not stored in a user-defined buffer—it is generated by Metal per thread.

kernel void gemm(
    device const float* A, 
    device const float* B, 
    device float* C, 
    device const uint* K_ptr,  // inner dimension size
    device const uint* N_ptr,
    device const uint* M_ptr,
    uint2 id [[thread_position_in_grid]],
    uint2 threadPositionInThreadgroup [[thread_position_in_threadgroup]]
    ) {
        int row = id.x;
        int col = id.y;
        uint K = K_ptr[0];
        uint N = N_ptr[0];
        uint M = M_ptr[0];

        threadgroup float tileA[TILE_SIZE][TILE_SIZE];
        threadgroup float tileB[TILE_SIZE][TILE_SIZE];

        float sum = 0.0;

        // for (uint tileIdx = 0; tileIdx < (K / TILE_SIZE); tileIdx++) {
        for (uint tileIdx = 0; tileIdx < (K + TILE_SIZE - 1) / TILE_SIZE; tileIdx++) {
            // local
            const int tileRow = threadPositionInThreadgroup.x;
            const int tileCol = threadPositionInThreadgroup.y;

            // load tiles
            tileA[threadPositionInThreadgroup.x][threadPositionInThreadgroup.y] = A[(row * K) + (tileIdx * TILE_SIZE + threadPositionInThreadgroup.y)];
            tileB[threadPositionInThreadgroup.x][threadPositionInThreadgroup.y] = B[((tileIdx * TILE_SIZE + threadPositionInThreadgroup.x) * N) + col];

            // synch all threads before computation
            threadgroup_barrier(mem_flags::mem_threadgroup);

            for (int k = 0; k < TILE_SIZE; k++) {
                sum += tileA[tileRow][k] * tileB[k][tileCol];
            }

            // synch again before loading the next tile
            threadgroup_barrier(mem_flags::mem_threadgroup);
        }

        C[row * N + col] = sum;
}
